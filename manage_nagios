#!/usr/bin/python3
import argparse
import time
import sys
import os
import glob

# TODO
# do I need object with host and service flags?
# if host flag is present and service flag is not
#   do host downtime
# if host flag is preset and service flag is present
#   do service downtime
# if host flag is not present and service flag is present
#   exit with error that host flag is required

# can I grab this from nagios.cfg?
cfg_path = '/local/nagios/etc/objects/'
host_group_path = '' # cfg_path + 'hostgroups/'

# build the parser
parser = argparse.ArgumentParser(description='stop things from alarming')
parser.add_argument('object', help='the object you want to put in downtime (host or service)')
parser.add_argument('--version', '-v', action='version', version='%(prog)s 1.0')
parser.add_argument('--hosts', '-H', type=str, help='host(s) or host group to put in downtime', required=True)
parser.add_argument('--services', '-S', type=str, help='service names to put in downtime')
parser.add_argument('--user', '-U', type=str, help='your username', required=True)
# parser.add_argument('--start', help='The time you would like downtime to start')
# parser.add_argument('--end', help='the time you would like downtime to end')
parser.add_argument('--duration', '-D', type=int, default=7200, help='length of time you want the host or service to be in downtime')
parser.add_argument('--comment', '-C', help='add a comment so others know what you are working on', required=True)

args = parser.parse_args()
h_groups = []
hg_members = []

#
for files in glob.glob(host_group_path + '*.cfg'):
    with open(files) as f:
        for line in f:
            if 'hostgroup_name' in line:
                h_groups.append(line.strip().split()[1])
                f.readline()
                hg_members.append(f.readline().strip().split()[1])


def host_downtime():
    # are there hosts
    if args.hosts:
        print(args.hosts.split(','))
    else:
        print('No hosts were provided')
        sys.exit()

    # if duration star time is now, end time is start + duration (in seconds)
    if args.duration:
        start_time = int(time.mktime(time.localtime()))
        end_time = int(time.mktime(time.localtime(args.duration)) + time.mktime(time.localtime()))


    for host in args.hosts.split(','):
        # check if host is a hostgroups else assume host
        if host in h_groups:
            print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOSTGROUP_HOST_DOWNTIME;{host};{start_time};{end_time};1;0;0;{args.user};{args.comment}')
            print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOST_SVC_DOWNTIME;{host};{start_time};{end_time};1;0;0;{args.user};{args.comment}')
            # put_in_downtime(84, host, start_time, end_time, user, comments)
            # put_in_downtime(85, host, start_time, end_time, user, comments)
        else:
            # put_in_downtime(55, host, start_time, end_time, user, comments)
            # put_in_downtime(86, host, start_time, end_time, user, comments)
            print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOST_DOWNTIME;{host};{start_time};{end_time};1;0;0;{args.user};{args.comment}')
            print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOST_SVC_DOWNTIME;{host};{start_time};{end_time};1;0;0;{args.user};{args.comment}')


def service_downtime():
    # are there services and hosts
    if args.services:
        print(args.services.split(','))
        print(args.hosts.split(','))
    else:
        print(os.path.basename(sys.argv[0]) + ': error: the following arguments are required: --services/-S')
        sys.exit()

        # if duration star time is now, end time is start + duration (in seconds)
    if args.duration:
        start_time = int(time.mktime(time.localtime()))
        end_time = int(time.mktime(time.localtime(args.duration)) + time.mktime(time.localtime()))

    for host in args.hosts.split(','):
        # check if host is a hostgroup else assume host
        if host in h_groups:
            for member in hg_members[h_groups.index(host)].split(','):
                for service in args.services.split(','):
                    print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOST_SVC_DOWNTIME;{member};{service};{start_time};{end_time};1;0;0;{args.user};{args.comment}')
            # put_in_downtime(84, host, start_time, end_time, user, comments)
            # put_in_downtime(85, host, start_time, end_time, user, comments)
        else:
            # put_in_downtime(55, host, start_time, end_time, user, comments)
            # put_in_downtime(86, host, start_time, end_time, user, comments)
            for service in args.services.split(','):
                print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOST_SVC_DOWNTIME;{member};{service};{start_time};{end_time};1;0;0;{args.user};{args.comment}')


def check_for_host():
    # objects/hosts/*
    pass


def check_for_service():
    # objects/services/*
    pass

def put_in_downtime():
    # pass in args
    # open nagios.cmd for write
    # write lines
    # close nagios.cmd

    # CMD_SCHEDULE_HOST_DOWNTIME                      55
    # CMD_SCHEDULE_HOST_SVC_DOWNTIME                  86

    # CMD_SCHEDULE_HOSTGROUP_HOST_DOWNTIME            84
    # CMD_SCHEDULE_HOSTGROUP_SVC_DOWNTIME             85

    # CMD_SCHEDULE_SVC_DOWNTIME                       56
    pass


if args.object == 'host' or args.object == 'hosts':
    host_downtime()
elif args.object == 'service' or args.object == 'services':
    service_downtime()
else:
    print(f'First argument should be host or service.')
    print(f'{os.path.basename(sys.argv[0])} {args.object} is not a valid option.')
    parser.print_help()
