#!/usr/bin/python3
import argparse
import time
import sys
import os
import glob

# can I grab this from nagios.cfg?
cfg_path = '/local/nagios/etc/objects/'
host_group_path = '' # cfg_path + 'h_groups/'

# build the parser
parser = argparse.ArgumentParser(description='stop things from alarming')
parser.add_argument('object', help='the object you want to put in downtime (host or service)')
parser.add_argument('--version', '-v', action='version', version='%(prog)s 1.0')
parser.add_argument('--hosts', '-H', type=str, help='host(s) or host group to put in downtime', required=True)
parser.add_argument('--services', '-S', type=str, help='service names to put in downtime')
parser.add_argument('--user', '-U', type=str, help='your username', required=True)
# parser.add_argument('--start', help='The time you would like downtime to start')
# parser.add_argument('--end', help='the time you would like downtime to end')
parser.add_argument('--duration', '-D', type=int, default=7200, help='length of time you want the host or service to be in downtime')
parser.add_argument('--comment', '-C', help='add a comment so others know what you are working on', required=True)

args = parser.parse_args()

# list of host groups that exist
# will use this to verify host group names when they're passed in
h_groups = []
hg_members = []
lines = []

for files in glob.glob('*.cfg'):
    with open(files) as f:
        for line in f:
            if 'hostgroup_name' in line:
                h_groups.append(line.strip().split()[1])
                f.readline()
                hg_members.append(f.readline().strip().split()[1])


def host_downtime():
    # are there hosts
    if args.hosts:
        print(args.hosts.split(','))
    else:
        print('No hosts were provided')
        sys.exit()

    # if duration star time is now, end time is start + duration (in seconds)
    if args.duration:
        start_time = int(time.mktime(time.localtime()))
        end_time = int(time.mktime(time.localtime(args.duration)) + time.mktime(time.localtime()))

    # check if hosts are host groups
    for host in args.hosts.split(','):
        if host in h_groups:
            for member in hg_members[h_groups.index(host)].split(','):
                print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOSTGROUP_HOST_DOWNTIME;{member};{start_time};{end_time};1;0;0;{args.user};{args.comment}')
                print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOST_SVC_DOWNTIME;{member};{start_time};{end_time};1;0;0;{args.user};{args.comment}')
                # put_in_downtime(84, host, start_time, end_time, user, comments)
                # put_in_downtime(85, host, start_time, end_time, user, comments)
        else:
            # put_in_downtime(55, host, start_time, end_time, user, comments)
            # put_in_downtime(86, host, start_time, end_time, user, comments)
            print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOST_DOWNTIME;{host};{start_time};{end_time};1;0;0;{args.user};{args.comment}')
            print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOST_SVC_DOWNTIME;{host};{start_time};{end_time};1;0;0;{args.user};{args.comment}')


def service_downtime():
    # are there services and hosts
    if args.services:
        print(args.services.split(','))
        print(args.hosts.split(','))
    else:
        print(os.path.basename(sys.argv[0]) + ': error: the following arguments are required: --services/-S')
        sys.exit()

        # if duration star time is now, end time is start + duration (in seconds)
    if args.duration:
        start_time = int(time.mktime(time.localtime()))
        end_time = int(time.mktime(time.localtime(args.duration)) + time.mktime(time.localtime()))

        # check if hosts are host groups
    for host in args.hosts.split(','):
        if host in h_groups:
            # put_in_downtime(84, host, start_time, end_time, user, comments)
            # put_in_downtime(85, host, start_time, end_time, user, comments)
            print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOSTGROUP_HOST_DOWNTIME;{host};{start_time};{end_time};1;0;0;{args.user};{args.comment}')
            print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOSTGROUP_SVC_DOWNTIME;{host};{start_time};{end_time};1;0;0;{args.user};{args.comment}')
        else:
            # put_in_downtime(55, host, start_time, end_time, user, comments)
            # put_in_downtime(86, host, start_time, end_time, user, comments)
            print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOST_DOWNTIME;{host};{start_time};{end_time};1;0;0;{args.user};{args.comment}')
            print(f'[{int(time.mktime(time.localtime()))}] SCHEDULE_HOST_SVC_DOWNTIME;{host};{start_time};{end_time};1;0;0;{args.user};{args.comment}')


def check_for_host():
    # objects/hosts/*
    pass


def check_for_service():
    # objects/services/*
    pass

def put_in_downtime():
    # pass in args
    # open nagios.cmd for write
    # write lines
    # close nagios.cmd

    # CMD_SCHEDULE_HOST_DOWNTIME                      55
    # CMD_SCHEDULE_HOST_SVC_DOWNTIME                  86

    # CMD_SCHEDULE_HOSTGROUP_HOST_DOWNTIME            84
    # CMD_SCHEDULE_HOSTGROUP_SVC_DOWNTIME             85

    # CMD_SCHEDULE_SVC_DOWNTIME                       56


    pass

if args.object == 'hosts':
    host_downtime()

if args.object == 'services':
    service_downtime()


# action
#   host downtime
#       host(s) or hostgroup name
#       username
#       optional args
#           start/end time (leave empty on default)
#           duration (2 hours default - compare to start/end if both are present to make sure they're ==)
#           comment (default = i'm bad and didn't leave a comment)

#   service downtime
#       service(s)
#       host(s) or hostgroup
#       username
#       optional args
#           start/end time (leave empty on default)
#           duration (2 hours default - compare to start/end if both are present to make sure they're ==)
#           comment (default = i'm bad and didn't leave a comment)

#   log data
#       time range
#           last X min/hours/days/months
#           start/end time
#       service(s)
#       host(s)

#   alert history
#       time range
#           last X min/hours/days/months
#           start/end time
#       service(s)
#       host(s)





# with open(args.filename) as f:
#     lines = f.readlines()
#     lines.reverse()
#
#     if args.limit:
#         lines = lines[:args.limit]
#
#     for line in lines:
#         print(line.strip()[::-1])

# parse the args

# read the file, reverse the contents and print